<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trabalho Prático 0 - AEDS III: src/lib/segtree.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trabalho Prático 0 - AEDS III
   &#160;<span id="projectnumber">0.0.0</span>
   </div>
   <div id="projectbrief">Trabalho Prático 2 de AEDS II</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_c85d3e3c5052e9ad9ce18c6863244a25.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">segtree.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &quot;<a class="el" href="segtree_8h_source.html">segtree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cell_8h_source.html">cell.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a321d199c21ac5c2ea399e04d2359a38c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#a321d199c21ac5c2ea399e04d2359a38c">SegTree_construct</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree, int pos, int *array, int start, int end)</td></tr>
<tr class="memdesc:a321d199c21ac5c2ea399e04d2359a38c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively constructs the Segment Tree.  <a href="#a321d199c21ac5c2ea399e04d2359a38c">More...</a><br /></td></tr>
<tr class="separator:a321d199c21ac5c2ea399e04d2359a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae59da709e330c52fd5c63566e2e7661d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#ae59da709e330c52fd5c63566e2e7661d">SegTree_size</a> (int n)</td></tr>
<tr class="memdesc:ae59da709e330c52fd5c63566e2e7661d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Segment Tree's number of nodes with the given the input array size.  <a href="#ae59da709e330c52fd5c63566e2e7661d">More...</a><br /></td></tr>
<tr class="separator:ae59da709e330c52fd5c63566e2e7661d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ffae627982fa7b5b3016b17c0a8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#ad62ffae627982fa7b5b3016b17c0a8f5">SegTree_create</a> (int *array, int n)</td></tr>
<tr class="memdesc:ad62ffae627982fa7b5b3016b17c0a8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Segment Tree.  <a href="#ad62ffae627982fa7b5b3016b17c0a8f5">More...</a><br /></td></tr>
<tr class="separator:ad62ffae627982fa7b5b3016b17c0a8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af716d4a3b5f3a55ecd42222903f61723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#af716d4a3b5f3a55ecd42222903f61723">SegTree_destroy</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree)</td></tr>
<tr class="memdesc:af716d4a3b5f3a55ecd42222903f61723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the given Segment Tree.  <a href="#af716d4a3b5f3a55ecd42222903f61723">More...</a><br /></td></tr>
<tr class="separator:af716d4a3b5f3a55ecd42222903f61723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecc161209d161c1a05460ec88a16b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#a9ecc161209d161c1a05460ec88a16b9b">SegTree_rangeQuery</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree, int pos, int start, int end, int currStart, int currEnd)</td></tr>
<tr class="memdesc:a9ecc161209d161c1a05460ec88a16b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a range query on the Segment Tree recursivelly.  <a href="#a9ecc161209d161c1a05460ec88a16b9b">More...</a><br /></td></tr>
<tr class="separator:a9ecc161209d161c1a05460ec88a16b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6debc45c2c1a99c3d6ad7ba59f2ca2fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#a6debc45c2c1a99c3d6ad7ba59f2ca2fb">SegTree_query</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree, int n, int start, int end)</td></tr>
<tr class="memdesc:a6debc45c2c1a99c3d6ad7ba59f2ca2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the recursive range query.  <a href="#a6debc45c2c1a99c3d6ad7ba59f2ca2fb">More...</a><br /></td></tr>
<tr class="separator:a6debc45c2c1a99c3d6ad7ba59f2ca2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28b83d7ff12677a1611a7f104f84b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#ac28b83d7ff12677a1611a7f104f84b34">SegTree_rangeUpdate</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree, int pos, int start, int end, int currStart, int currEnd, int(*transform)(int n))</td></tr>
<tr class="memdesc:ac28b83d7ff12677a1611a7f104f84b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively updates the Segment Tree.  <a href="#ac28b83d7ff12677a1611a7f104f84b34">More...</a><br /></td></tr>
<tr class="separator:ac28b83d7ff12677a1611a7f104f84b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace52cee81e0db45fff135ce4fd535ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segtree_8c.html#ace52cee81e0db45fff135ce4fd535ab2">SegTree_update</a> (<a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *segtree, int n, int start, int end, int(*transform)(int n))</td></tr>
<tr class="memdesc:ace52cee81e0db45fff135ce4fd535ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for the recursive segtree update.  <a href="#ace52cee81e0db45fff135ce4fd535ab2">More...</a><br /></td></tr>
<tr class="separator:ace52cee81e0db45fff135ce4fd535ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a321d199c21ac5c2ea399e04d2359a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321d199c21ac5c2ea399e04d2359a38c">&#9670;&nbsp;</a></span>SegTree_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SegTree_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively constructs the Segment Tree. </p>
<p>Complexity:</p>
<p>With n being the Segment Tree's number of nodes, the complexity is O(n), because we need to visit every node of the tree to calculate its data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">segtree</td><td>The Segment Tree array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The current position on the segtree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval (0-indexed, inclusive) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad62ffae627982fa7b5b3016b17c0a8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62ffae627982fa7b5b3016b17c0a8f5">&#9670;&nbsp;</a></span>SegTree_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a>* SegTree_create </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Segment Tree. </p>
<p>Complexity:</p>
<p>The complexity for creating a new Segment Tree is related to the function SegTree_construct, which is O(N), being N the number of nodes of the tree.</p>
<p>The number of nodes N, in the best case is 2·n-1, with n being the input array length. In worst case N will not pass from 4·n-1. The full explanation for this is on the SegTree_size function description.</p>
<p>In all cases, the complexity for creating a new Segment Tree is O(n).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>The input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The input array length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created Segment Tree </dd></dl>

</div>
</div>
<a id="af716d4a3b5f3a55ecd42222903f61723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af716d4a3b5f3a55ecd42222903f61723">&#9670;&nbsp;</a></span>SegTree_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SegTree_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the given Segment Tree. </p>
<p>Complexity: O(1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segtree</td><td>The segtree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6debc45c2c1a99c3d6ad7ba59f2ca2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6debc45c2c1a99c3d6ad7ba59f2ca2fb">&#9670;&nbsp;</a></span>SegTree_query()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> SegTree_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for the recursive range query. </p>
<p>Complexity: The complexity here is related to the complexity of the SegTree_rangeQuery function, which is O(log N), being N the number of nodes of the tree.</p>
<p>The number of nodes N, in the best case is 2·n-1, with n being the input array length. In worst case N will not pass from 4·n-1. The full explanation for this is on the SegTree_size function description.</p>
<p>With 2·n-1 or 4·n-1, the complexity of the function is O(log n).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">segtree</td><td>The segtree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The input array length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval (1-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval (1-indexed, inclusive)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The results of the query </dd></dl>

</div>
</div>
<a id="a9ecc161209d161c1a05460ec88a16b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ecc161209d161c1a05460ec88a16b9b">&#9670;&nbsp;</a></span>SegTree_rangeQuery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> SegTree_rangeQuery </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a range query on the Segment Tree recursivelly. </p>
<p>Complexity:</p>
<p>In the best case, the range of the query will be from 0 to (L - 1), being L the length of the input array. In this case, the complexity for retrieving data from the segtree is O(1).</p>
<p>In the worst case, the range of the query will have length of 1 (query of 1 element). In this case, the alghoritm will dive into the tree til reach the correspondant leaf. The complexity for retrieving the leaf data will be of O(H), with H begin the height of the tree.</p>
<p>As the Segment Tree is a Full Binary Tree, the height of the tree will correspond log N, being N the number of nodes. So the complexity for retrieving data from a leaf is O(log N).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">segtree</td><td>The segtree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The position </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currStart</td><td>The current start of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currEnd</td><td>The current end of the interval (0-indexed, inclusive)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The results of the query </dd></dl>

</div>
</div>
<a id="ac28b83d7ff12677a1611a7f104f84b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28b83d7ff12677a1611a7f104f84b34">&#9670;&nbsp;</a></span>SegTree_rangeUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SegTree_rangeUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int n)&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively updates the Segment Tree. </p>
<p>Complexity:</p>
<p>As the updates are realized on the leafs of the tree, and then the nodes that represent the intervals have to be updated, the cost on the update will be related to the amount of nodes that has to be updated plus the height of the tree. The cost to reach a leaf is log H, being H the height of the tree. Let LF the number of leafs to be updated, that is the same as the size of the interval to be updated (end-start-1).</p>
<p>As the Segment Tree is a Full Binary Tree, the height of the tree will correspond log N, being N the number of nodes. So the complexity for retrieving data from a leaf is O(log N).</p>
<p>The complexity of a update is O(LF·log N).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">segtree</td><td>The segtree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pos</td><td>The current position on the segtree array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currStart</td><td>The current start of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currEnd</td><td>The current end of the interval (0-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>The function that will transform the leafs data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae59da709e330c52fd5c63566e2e7661d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae59da709e330c52fd5c63566e2e7661d">&#9670;&nbsp;</a></span>SegTree_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SegTree_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Segment Tree's number of nodes with the given the input array size. </p>
<p>The number of nodes n required for a segtree is calculated with the length of the input array. In the best case, the length L is a power of 2, so the number of nodes is n=2·L-1. If L is not a power of 2, we have to find the next power of 2 after L. In this case, the number of nodes will not pass from n=2·2^((log L) + 1) - 1, which can be simplified to n=4·L-1.</p>
<p>Being n the input array length, let np the power of 2 that is equal or higher than n. The size of the Segment Tree array will be 2·np-1.</p>
<p>The strategy adopted here is to calculate the log2 of n and get the ceil of the result. This way, we can power 2 for the result and get the next power of 2. Then, we use 2·(2^np)-1 to get the the size of the Segment Tree array.</p>
<p>Complexity: (1)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The input array size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the Segment Tree array </dd></dl>

</div>
</div>
<a id="ace52cee81e0db45fff135ce4fd535ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace52cee81e0db45fff135ce4fd535ab2">&#9670;&nbsp;</a></span>SegTree_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SegTree_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cell_8h.html#a5a015017629833d016e38b49dca7b1c3">Cell</a> *&#160;</td>
          <td class="paramname"><em>segtree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(int n)&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for the recursive segtree update. </p>
<p>Complexity: The complexity here is related to the complexity of the SegTree_rangeUpdate function, which is O(LF·log N), being N the number of nodes of the tree, and LF is end - start - 1.</p>
<p>The number of nodes N, in the best case is 2·n-1, with n being the input array length. In worst case N will not pass from 4·n-1. The full explanation for this is on the SegTree_size function description.</p>
<p>With 2·n-1 or 4·n-1, the complexity of the function is O(LF·log n).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">segtree</td><td>The segtree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The length of the input array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>The start of the interval (1-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>The end of the interval (1-indexed, inclusive) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>The transform function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
